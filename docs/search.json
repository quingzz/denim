[{"path":[]},{"path":"/articles/deSolve_to_denim.html","id":"original-code-in-desolve","dir":"Articles","previous_headings":"Migrate deSolve code to denim","what":"Original code in deSolve","title":"deSolve to denim","text":"model used demonstrating process migrating code deSolve denim followed","code":"# --- Model definition in deSolve transition_func <- function(t, state, param){   with(as.list( c(state, param) ), {       dS = -beta*S*I/N       dI1 = beta*S*I/N - rate*I1       dI2 = rate*I1 - rate*I2       dI =  dI1 + dI2       dR = rate*I2       list(c(dS, dI, dI1, dI2, dR))   }) }  # ---- Model configuration  parameters <- c(beta = 0.3, rate = 1/3, N = 1000)  initialValues <- c(S = 999, I = 1, I1 = 1, I2=0, R=0)  # ---- Run simulation times <- seq(0, 100) # simulation duration ode_mod <- ode(y = initialValues, times = times, parms = parameters, func = transition_func)  # --- show output ode_mod <- as.data.frame(ode_mod) head(ode_mod[-1, c(\"time\", \"S\", \"I\", \"R\")]) ##   time        S        I          R ## 2    1 998.6561 1.294182 0.04969647 ## 3    2 998.2239 1.594547 0.18152864 ## 4    3 997.6985 1.921416 0.38010527 ## 5    4 997.0695 2.290735 0.63971843 ## 6    5 996.3225 2.716551 0.96093694 ## 7    6 995.4387 3.212577 1.34869352"},{"path":"/articles/deSolve_to_denim.html","id":"model-definition","dir":"Articles","previous_headings":"Migrate deSolve code to denim","what":"Model definition","title":"deSolve to denim","text":"Unlike deSolve transitions compartments defined system ODEs, transitions denim must defined () distribution dwell-time, (ii) mathematical expression, (iii) fixed number proportion. User must first identify transitions best describe ones deSolve model. transitions identified, user can define model denim. using denim, model structure given list key-value pairs key string showing transition direction compartments value built-distribution function describe transition Note converting ODE math expression, must multiply original expression time step duration (variable timestepDur model definition code). essentially using Euler’s method estimate solution ODE.","code":"# --- Model definition in deSolve transition_func <- function(t, state, param){   with(as.list( c(state, param) ), {              # For S -> I transition, since it involves parameters (beta, N),        # the best transition to describe this is using a mathematical formula       dS = -beta*S*I/N              # For I -> R transition, linear chain trick is applied --> implies Erlang distributed dwell time       # Hence, we can use d_gamma from denim       dI1 = beta*S*I/N - rate*I1       dI2 = rate*I1 - rate*I2       dI =  dI1 + dI2       dR = rate*I2       list(c(dS, dI, dI1, dI2, dR))   }) } # --- Transition def for denim transitions <- list(   \"S -> I\" = \"beta * S * I/N * timestepDur\",   \"I -> R\" = d_gamma(rate = 1/3, shape = 2) # shape is 2 from number of I sub compartments )"},{"path":"/articles/deSolve_to_denim.html","id":"model-configurations","dir":"Articles","previous_headings":"Migrate deSolve code to denim","what":"Model configurations","title":"deSolve to denim","text":"Similar deSolve, denim also ask users provide initial values additional parameters form named vectors. example deSolve code, users can use initalValues deSolve code (denim ignore unused I1, I2 compartments sub-compartments automatically computed internally), recommended remove redundant compartments (example, I1 I2). parameters, since rate already defined distribution functions, users need keep beta N initial parameters vector. also need specify value timestepDur . Initialization sub-compartments: multiple sub-compartments (e.g., compartment consist I1 I2 sub-compartments), initial population always assigned first sub-compartment. example, since = 1, denim assign I1 = 1 I2 = 0.","code":"# remove I1, I2 compartments denim_initialValues <- c(S = 999, I = 1, R=0) denim_parameters <- c(beta = 0.3, N = 1000, timestepDur=0.01)"},{"path":"/articles/deSolve_to_denim.html","id":"simulation","dir":"Articles","previous_headings":"Migrate deSolve code to denim","what":"Simulation","title":"deSolve to denim","text":"Lastly, users need define simulation duration time step denim run. Unlike deSolve takes time sequence, denim require simulation duration time step. Since denim discrete time model, time step must set small value result closely follow deSolve (example, 0.01).","code":"mod <- sim(transitions = transitions,              initialValues = denim_initialValues,               parameters = denim_parameters,              simulationDuration = 100,              timeStep = 0.01)  head(mod[mod$Time %% 1 == 0, ]) ##     Time        S        I          R ## 1      0 999.0000 1.000000 0.00000000 ## 101    1 998.6566 1.293759 0.04961535 ## 201    2 998.2251 1.593725 0.18121212 ## 301    3 997.7004 1.920189 0.37940195 ## 401    4 997.0725 2.289061 0.63848007 ## 501    5 996.3266 2.714365 0.95900520"},{"path":"/articles/deSolve_to_denim.html","id":"compare-output","dir":"Articles","previous_headings":"","what":"Compare output","title":"deSolve to denim","text":"following plots show output denim deSolve","code":""},{"path":"/articles/denim.html","id":"simple-sir-model-with-gamma-distributed-lengths-of-stay","dir":"Articles","previous_headings":"","what":"1. Simple SIR model with gamma distributed lengths of stay","title":"denim: deterministic discrete-time model with memory","text":"SIR model uses 3 compartments: S (susceptible), (infected), R (recovered) describe clinical status individuals. use simple form SIR model demonstrate define distribution lengths stay distribution. model equations : \\[S_{t+1} - S_{t} = -\\lambda S_{t} = -\\frac{\\beta I_{t}}{N}S_{t}\\] \\[I_{t+1} - I_{t} = \\frac{\\beta I_{t}}{N}S_{t} - \\gamma I_{t}\\] \\[R_{t+1} - R_{t} = \\gamma I_{t}\\] \\(N\\): total population size, \\(N = S + + R\\) \\(\\beta\\): product contact rates transmission probability; usually define \\(\\lambda =\\frac{\\beta I_{t}}{N}\\) force infection \\(\\gamma\\): recovery rate Usually solve model easier make assumption recovery rate \\(\\gamma\\) constant, leads exponentially distributed length stay .e individuals recover 1 day infected.  realistic length stay distribution can look like , patients recovered 4 days. defined using gamma distribution shape = 3 rate = 1/2.  model now look like : Model specification Model transition two transitions S -> -> R case. transitions specified list follow format \"transition\" = equation, equation defined one functions waiting time distribution. Initial state Use vector define compartments assigned names initial values format compartment_name = initial_value: Model parameters use math expression, symbols except compartment names parameters, defined constant values. two constant parameters example: beta N: Model application Time step specification run model 30 days give output 0.01 daily intervals. default interval (time step) 1 declared explicitly.","code":"transitions <- list(   \"S -> I\" = \"beta * S * I / N\",   \"I -> R\" = d_gamma(rate = 1/2, 3) ) initialValues <- c(   S = 999,    I = 1,    R = 0 ) parameters <- c(   beta = 0.012,   N = 1000 ) simulationDuration <- 30 timeStep <- 0.01 mod <- sim(transitions = transitions,             initialValues = initialValues,             parameters = parameters,             simulationDuration = simulationDuration,             timeStep = timeStep) head(mod) #>   Time        S        I            R #> 1 0.00 999.0000 1.000000 0.000000e+00 #> 2 0.01 998.9880 1.011988 2.075536e-08 #> 3 0.02 998.9759 1.024119 1.656705e-07 #> 4 0.03 998.9636 1.036396 5.584446e-07 #> 5 0.04 998.9512 1.048819 1.322422e-06 #> 6 0.05 998.9386 1.061390 2.580606e-06 plot(mod)"},{"path":"/articles/denim.html","id":"how-the-algorithm-work","dir":"Articles","previous_headings":"","what":"2. How the algorithm work?","title":"denim: deterministic discrete-time model with memory","text":"SIR model, infected individuals presented single compartment recovery rate \\(\\gamma\\). want recovery rate individuals infected 1 day differ recovery rate 2-day infected patients. rather using one compartment infected (), define multiple infected sub-compartments. number sub-compartments depends maximum day expect infected individuals recovered. example, expect disease maximum 4 days infection, end 4 sub-compartments. sub-compartment recovery rate \\(\\gamma_{1}\\), \\(\\gamma_{2}\\), \\(\\gamma_{3}\\), \\(\\gamma_{4}\\). day 4 certain patient recover (assume disease maximum 4 days infection), \\(\\gamma_{4} = 1\\). Let \\(R_1 + R_2 + R_3 + R_4 = \\Sigma R\\). \\(\\frac{R_1}{\\Sigma R} = p_1\\), \\(\\frac{R_2}{\\Sigma R} = p_2\\), \\(\\frac{R_3}{\\Sigma R} = p_3\\), \\(\\frac{R_4}{\\Sigma R} = p_4\\). mission estimate \\(\\gamma_{1}\\), \\(\\gamma_{2}\\), \\(\\gamma_{3}\\) obtain \\(p_1\\), \\(p_2\\), \\(p_3\\), \\(p_4\\) fit pre-defined distribution equilibrium state. can obtained setting: \\[\\gamma_{} = \\frac{p_i}{1 - \\sum_{j=1}^{-1}p_j}\\] given length stay distribution, identify maximum length stay using cumulative distribution function. cumulative distribution function asymptotic 1 never equal 1, need set value acceptable rounded 1. want cumulative probability 0.999 rounded 1, set error tolerance threshold 1 - 0.999 = 0.001 (specified argument errorTolerance = 0.001). time cumulative probability = 0.999 set maximum length stay compartment. Default errorTolerance denim set 0.001. Initialize population sub-compartments default, initial population always assigned first sub-compartment (example, initial value compartment = 1, denim initialize I1 = 1 I2 = I3 = I4 = 0). User can also choose distribute initial population across sub-compartments based specified distribution, .e. initial population = n, denim initialize I1 = n*p1, I2 = n*p2, I3 = n*p3, I4 = n*p4. set initial population way, simply specify parameter dist_init = TRUE (applicable distribution transitions).","code":"transitions <- list(   \"S -> I\" = \"beta * S * I / N\",   \"I -> R\" = d_gamma(rate = 1/2, 3, dist_init=TRUE) )"},{"path":"/articles/denim.html","id":"waiting-time-distribution","dir":"Articles","previous_headings":"","what":"3. Waiting time distribution","title":"denim: deterministic discrete-time model with memory","text":"denim offers 2 main ways define transition: either waiting time distribution, mathematical expression. Current available distributions package including: d_exponential(rate): Discrete exponential distribution parameter rate d_gamma(rate, shape): Discrete gamma distribution parameters rate shape d_weibull(scale, shape): Discrete Weibull distribution parameters scale shape d_lognormal(mu, sigma): Discrete log-normal distribution parameters mu sigma nonparametric(waitingTimes...): vector values, numbers, percentages, density length stay based real data, denim convert distribution Mathematical expression: Transition defined string value \"beta * S * / N\" converted mathematical expression. need define parameters compartment names parameters argument","code":""},{"path":"/articles/denim.html","id":"multiple-transitions-from-a-compartment","dir":"Articles","previous_headings":"","what":"4. Multiple transitions from a compartment","title":"denim: deterministic discrete-time model with memory","text":"denim, transitions one compartment multiple compartments modeled multinomial transition. Consider example: two scenarios example: Susceptible individuals can infected vaccinated. underlying assumption 50% susceptible infected (S -> ), remaining 50% get vaccinated (S -> V). Infected individuals can recover die. mortality probability known, can implement model, example defining 0.9 * -> R (90% individuals recover) 0.1 * -> D (10% die). , ensure mortality probability 10%, also define length stay individuals infected state recover die follows gamma log-normal distribution, respectively. can define model example follows:  detailed explanation multinomial transition, refer article","code":"transitions <- list(   \"S -> I\" = \"beta * S * I / N\",   \"S -> V\" = 5,   \"0.9 * I -> R\" = d_gamma(1/3, 2),   \"0.1 * I -> D\" = d_lognormal(2, 0.5) )  initialValues <- c(   S = 999,    I = 1,    R = 0,   V = 0,   D = 0 )  parameters <- c(   beta = 0.12,   N = 1000 )  simulationDuration <- 10 timeStep <- 0.01  mod <- sim(transitions = transitions,             initialValues = initialValues,             parameters = parameters,             simulationDuration = simulationDuration,             timeStep = timeStep)  head(mod) #>   Time        S        I  V            R            D #> 1 0.00 999.0000 1.000000  0 0.000000e+00 0.000000e+00 #> 2 0.01 993.8801 1.119875  5 4.988903e-06 0.000000e+00 #> 3 0.02 988.7466 1.253422 10 2.050940e-05 1.466074e-33 #> 4 0.03 983.5978 1.402113 15 4.775442e-05 1.651901e-29 #> 5 0.04 978.4323 1.567566 20 8.805255e-05 8.337600e-27 #> 6 0.05 973.2483 1.751562 25 1.428825e-04 8.315472e-25 plot(mod)"},{"path":"/articles/denim.html","id":"another-example","dir":"Articles","previous_headings":"","what":"5. Another example","title":"denim: deterministic discrete-time model with memory","text":"","code":"transitions <- list(   \"S -> I\" = \"beta * S * (I + IV) / N\",   \"S -> V\" = 2,   \"0.1 * I -> D\" = d_lognormal(2, 0.5),   \"0.9 * I -> R\" = d_gamma(rate = 1/3, shape = 2),   \"V -> IV\" = \"0.1 * beta * V * (I + IV) / N\",   \"IV -> R\" = d_exponential(2) )  initialValues <- c(   S = 999,    I = 1,    R = 0,   V = 0,   IV = 0,   D = 0 )  parameters <- c(   beta = 0.12,   N = 1000 )  simulationDuration <- 10 timeStep <- 0.01  mod <- sim(transitions = transitions,             initialValues = initialValues,             parameters = parameters,             simulationDuration = simulationDuration,             timeStep = timeStep) plot(mod) transitions <- list(   \"M -> S\" = 100,   \"S -> I\" = transprob(1),   \"S -> R\" = transprob(1) )  initialValues <- c(   M = 1000,   S = 500,    I = 0,    R = 0 )  simulationDuration <- 10 timeStep <- 0.01  mod <- sim(transitions = transitions,             initialValues = initialValues,             parameters = parameters,             simulationDuration = simulationDuration,             timeStep = timeStep) head(mod) #>   Time    M   S   I   R #> 1 0.00 1000 500 0.0 0.0 #> 2 0.01  900 595 2.5 2.5 #> 3 0.02  800 694 3.0 3.0 #> 4 0.03  700 793 3.5 3.5 #> 5 0.04  600 892 4.0 4.0 #> 6 0.05  500 991 4.5 4.5"},{"path":"/articles/denim_benchmark.html","id":"benchmark-settings","dir":"Articles","previous_headings":"","what":"Benchmark settings","title":"denim benchmark","text":"approaches simulate following SEIR model, simulation duration 180 approach run 50 times","code":"total_runs <- 50L # number of runs sim_duration <- 180 # duration of simulation"},{"path":"/articles/denim_benchmark.html","id":"useir","dir":"Articles","previous_headings":"","what":"uSEIR","title":"denim benchmark","text":"Simulate model using uSEIR approach (Hernández et al. 2021) Source code: https://github.com/jjgomezcadenas/useirn/blob/master/nb/uSEIR.ipynb","code":"library(reticulate) ## Warning: package 'reticulate' was built under R version 4.3.3 # use_python(\"/opt/anaconda3/envs/bnn/bin/python\", required = TRUE) use_condaenv(condaenv='bnn', required = TRUE) matplotlib <- import(\"matplotlib\") matplotlib$use(\"Agg\", force = TRUE) py_run_file(\"../supplements/useir_python.py\")"},{"path":"/articles/denim_benchmark.html","id":"python-implementation","dir":"Articles","previous_headings":"uSEIR","what":"Python implementation","title":"denim benchmark","text":"Run time uSEIR approach, Python implementation (seconds) Median run time uSEIR approach, Python implementation: 53.7090955 seconds","code":"import time import concurrent.futures import pickle import os from statistics import mean  python_runs = []  def get_python_runtime(n):   start = time.time()   df = solve_uSeir(ti_shape     = 2,                      ti_scale     = 4,                      tr_shape     = 2,                      tr_scale     = 3,                      R0           = 3.5)   end = time.time()   return end - start    # load cached result if available instead of rerun due to long run time cached_python_runs = \"../supplements/python_runs.pkl\" if os.path.exists(cached_python_runs):   # If the file exists, load the Python list from the file   with open(cached_python_runs, 'rb') as f:     python_runs = pickle.load(f) else:   print(\"no cache found\")   # multithread instead for quicker result   with concurrent.futures.ProcessPoolExecutor(max_workers=8) as executor:     python_runs = list(executor.map(get_python_runtime, range(r.total_runs)))    # mean(python_runs)  # plot_useir((df,), ('G',), T = 'uSEIR', figsize=(14,8)) # print(f'python solve_seir call: dr = {end-start}') py$python_runs ##  [1] 54.79370 54.23037 54.61863 54.13476 54.73439 54.35928 54.48391 54.56821 ##  [9] 53.26567 53.35437 53.44551 53.31425 53.51092 53.19878 53.92493 53.84889 ## [17] 54.05378 53.66922 53.65536 53.54520 53.73345 53.88690 54.23988 54.19460 ## [25] 53.64543 53.55217 53.66061 53.67430 53.59397 53.65503 54.32232 53.98363 ## [33] 53.53084 53.79021 53.85689 53.45313 53.61043 53.53294 54.00833 54.11180 ## [41] 53.94760 53.61952 53.80676 53.74364 53.68474 53.63701 53.59615 53.81793 ## [49] 44.74661 44.77127"},{"path":"/articles/denim_benchmark.html","id":"cython-implementation","dir":"Articles","previous_headings":"uSEIR","what":"Cython implementation","title":"denim benchmark","text":"Run time uSEIR approach, Cython implementation (seconds) Median run time uSEIR approach, Cython implementation: 0.4025744 seconds","code":"# import precompiled cython module import sys sys.path.insert(0, \"../supplements\") import useir import time import pyarrow as pa  cython_runs = []  # --- Get runtime ---- for i in range(r.total_runs):   start = time.time()   df = useir.csolve_uSeir(dist = \"gamma\",                     ti_shape     = 2,                      ti_scale     = 4,                      tr_shape     = 2,                      tr_scale     = 3,                      R0           = 3.5   )   end = time.time()    cython_runs = cython_runs + [end - start] ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 # ---- Get output for uSEIR ----- df = useir.csolve_uSeir(dist = \"gamma\",                     ti_shape     = 2,                      ti_scale     = 4,                      tr_shape     = 2,                      tr_scale     = 3,                      R0           = 3.5   ) ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 # convert to pyarrow table for easy conversion to R data.frames to_r_df = pa.Table.from_pandas(df) py$cython_runs ##  [1] 0.4023190 0.4008489 0.3996522 0.4021759 0.3954298 0.3997641 0.4049480 ##  [8] 0.3938949 0.4050941 0.3948798 0.3939130 0.3927512 0.3971188 0.4034030 ## [15] 0.3942008 0.4020801 0.3934939 0.4020162 0.4203770 0.4100389 0.4032271 ## [22] 0.3963428 0.3941231 0.4065132 0.4022820 0.4152899 0.4040892 0.4039760 ## [29] 0.4112580 0.4038100 0.4072459 0.3957858 0.3960719 0.3979449 0.4026759 ## [36] 0.4030762 0.4009969 0.4145489 0.4091511 0.4061022 0.3969009 0.4102721 ## [43] 0.4054501 0.4031701 0.4024730 0.4103858 0.4159880 0.4060838 0.4022591 ## [50] 0.4051421"},{"path":[]},{"path":"/articles/denim_benchmark.html","id":"model-in-r","dir":"Articles","previous_headings":"deSolve","what":"Model in R","title":"denim benchmark","text":"Run time deSolve implementation Median run time deSolve, model defined R: 0.0032842 seconds","code":"library(deSolve) ## Warning: package 'deSolve' was built under R version 4.3.1 parameters <- c(gamma_rate_I = 1/4, shape_I=2,                 gamma_rate_R = 1/3, shape_R = 2,                 R0 = 3.5, N = 1e6)  initialValues <- c(S = 999999, E1 = 1,                    E2 = 0, E = 0, I1=0,                     I2=0, I=0, R=0                    )  # --- Transition def for deSolve transition_func <- function(t, state, param){   with(as.list( c(state, param) ), {       tr = shape_R*(1/gamma_rate_R)              dS = - (R0/tr) * S * I/N       # apply linear chain trick       dE1 = (R0/tr) * S * I/N - gamma_rate_I*E1       dE2 = gamma_rate_I*E1 - gamma_rate_I*E2       dE = dE1 + dE2       dI1 = gamma_rate_I*E2 - gamma_rate_R*I1       dI2 = gamma_rate_R*I1 - gamma_rate_R*I2       dI =  dI1 + dI2        dR = gamma_rate_R*I2       list(c(dS, dE1, dE2, dE, dI1, dI2, dI, dR))   }) }  times <- seq(0, sim_duration, 1)  # ------ Compute run time ------ desolve_runs <- bench::mark(   ode(y = initialValues, times = times, parms = parameters, func = transition_func),   iterations = total_runs )  ode_mod <- ode(y = initialValues, times = times, parms = parameters, func = transition_func)  ode_mod <- as.data.frame(ode_mod) desolve_runs$time ## [[1]] ##  [1]  3.52ms  3.25ms  3.5ms   3.37ms  6.18ms  3.4ms   3.19ms  3.44ms  3.31ms ## [10]  3.32ms  3.22ms  3.36ms  3.3ms   3.37ms  5.06ms  3.11ms  3.25ms  3.3ms  ## [19]  3.34ms  3.26ms  3.15ms  3.28ms  3.17ms  5.14ms  3.35ms  3.42ms  3.31ms ## [28]  3.18ms  3.24ms  3.13ms  3.33ms  3.36ms  5.65ms  3.2ms   3.25ms  3.28ms ## [37]  3.23ms  3.24ms  3.23ms  3.27ms  3.25ms 26.9ms   3.26ms  3.36ms  3.39ms ## [46]  3.46ms  3.36ms  3.31ms  3.2ms   3.14ms"},{"path":"/articles/denim_benchmark.html","id":"model-in-c","dir":"Articles","previous_headings":"deSolve","what":"Model in C","title":"denim benchmark","text":"Run time deSolve model defined C Median run time deSolve, model defined C: 1.2757155^{-4} seconds","code":"# compile model # system(\"R CMD SHLIB supplements/desolve_mod/benchmark_mod.c\")  # compiled file on Windows will have .dll extension instead of .so dyn.load(\"../supplements/desolve_mod/benchmark_mod.so\")  initialValues <- c(S = 999999, E1 = 1,                    E2 = 0, E = 0, I1=0,                     I2=0, I=0, R=0                    )  parameters <- c(R0 = 3.5, scale_I = 4, shape_I=2,                 scale_R = 3, shape_R = 2, N = 1e6)   deSolve_c_runs <- bench::mark(   # run model defined in C   ode(initialValues, times, func = \"derivs\", parms = parameters,   dllname = \"benchmark_mod\", initfunc = \"initmod\"),   iterations = total_runs )  dyn.unload(\"../supplements/desolve_mod/benchmark_mod.so\") deSolve_c_runs$time ## [[1]] ##  [1] 165µs 204µs 138µs 165µs 131µs 129µs 155µs 130µs 147µs 122µs 123µs 146µs ## [13] 126µs 144µs 122µs 124µs 145µs 123µs 145µs 124µs 123µs 151µs 124µs 147µs ## [25] 123µs 120µs 140µs 117µs 138µs 119µs 117µs 138µs 118µs 140µs 116µs 116µs ## [37] 143µs 117µs 138µs 116µs 117µs 137µs 117µs 139µs 116µs 121µs 144µs 120µs ## [49] 142µs 120µs"},{"path":"/articles/denim_benchmark.html","id":"model-in-fortran","dir":"Articles","previous_headings":"deSolve","what":"Model in Fortran","title":"denim benchmark","text":"Median run time deSolve, model defined Fortran: 1.7679203^{-4} seconds","code":"# compile model in fortran # system(\"R CMD SHLIB supplements/desolve_mod/benchmark_mod_fortran.f\")  dyn.load(\"../supplements/desolve_mod/benchmark_mod_fortran.so\")  initialValues <- c(S = 999999, E1 = 1,                    E2 = 0, E = 0, I1=0,                     I2=0, I=0, R=0                    )  parameters <- c(R0 = 3.5, scale_I = 4, shape_I=2,                 scale_R = 3, shape_R = 2, N = 1e6)   deSolve_fortran_runs <- bench::mark(   # run model defined in C   ode(initialValues, times, func = \"derivs\", parms = parameters,   dllname = \"benchmark_mod_fortran\", initfunc = \"initmod\"),   iterations = total_runs )  dyn.unload(\"../supplements/desolve_mod/benchmark_mod_fortran.so\") deSolve_fortran_runs$time ## [[1]] ##  [1] 393µs 202µs 224µs 178µs 177µs 203µs 173µs 198µs 164µs 172µs 196µs 176µs ## [13] 192µs 167µs 171µs 196µs 171µs 186µs 174µs 171µs 190µs 175µs 183µs 164µs ## [25] 175µs 192µs 171µs 206µs 167µs 165µs 192µs 173µs 187µs 167µs 167µs 186µs ## [37] 169µs 188µs 177µs 169µs 187µs 173µs 187µs 173µs 175µs 192µs 168µs 198µs ## [49] 175µs 179µs"},{"path":"/articles/denim_benchmark.html","id":"denim","dir":"Articles","previous_headings":"","what":"denim","title":"denim benchmark","text":"Run time denim implementation Median run time denim: 0.7171607 seconds","code":"library(denim)  denim_model <- list(   \"S -> E\" = \"(R0/tr) * timeStep * S * (I/N)\", # formulate according that of uSEIR method   \"E -> I\" = d_gamma(rate = 1/4, shape = 2),   \"I -> R\" = d_gamma(rate = 1/3, shape = 2) )  initialValues <- c(S = 999999, E = 1, I= 0, R= 0) parameters <- c(R0 = 3.5,                  tr = 3*2, # compute mean recovery time, for gamma it's scale*shape                 N = 1e6)  # ---- Get runtimes ---- denim_runs <- bench::mark(   sim(transitions = denim_model,                      initialValues = initialValues,                      parameters = parameters,                      simulationDuration = sim_duration, timeStep = 0.05),   iterations = total_runs )   # ---- Get output ---- denim_out <- sim(transitions = denim_model,                       initialValues = initialValues,                      parameters = parameters,                      simulationDuration = sim_duration, timeStep = 0.05) denim_runs$time ## [[1]] ##  [1] 713ms 712ms 718ms 716ms 717ms 733ms 733ms 727ms 719ms 712ms 708ms 711ms ## [13] 717ms 719ms 713ms 716ms 723ms 714ms 725ms 726ms 719ms 714ms 727ms 732ms ## [25] 718ms 713ms 713ms 716ms 716ms 713ms 715ms 711ms 714ms 713ms 714ms 715ms ## [37] 713ms 719ms 728ms 719ms 719ms 718ms 718ms 717ms 718ms 718ms 717ms 717ms ## [49] 718ms 717ms"},{"path":[]},{"path":"/articles/denim_benchmark.html","id":"compare-run-time","dir":"Articles","previous_headings":"","what":"Compare run time","title":"denim benchmark","text":"following plot shows run time 50 runs (horizontal line showing median run time) approach.","code":""},{"path":"/articles/denim_benchmark.html","id":"run-time-scaling-in-denim","dir":"Articles","previous_headings":"","what":"Run time scaling in denim","title":"denim benchmark","text":"worth noting runtime denim also dependent duration time step (timeStep parameter sim). following plot demonstrates run time changes value timeStep changes, using model benchmarking. values timeStep evaluated [0.01, 0.02, 0.05, 0.1, 0.25, 0.5, 1].","code":""},{"path":"/articles/denim_vs_deSolve.html","id":"comparison-between-desolve-and-denim","dir":"Articles","previous_headings":"","what":"Comparison between deSolve and denim","title":"denim vs deSolve","text":"","code":"library(denim) library(deSolve) ## Warning: package 'deSolve' was built under R version 4.3.1 # --- Timestep definition simulationDuration <- 300  timestep <- 0.01 # small timestep required for comparison  # --- Transition def for denim transitions <- list(   # note that timeStep uses the timeStep parameter in denim::sim()    \"S -> I\" = \"beta * S * (I/N) * timeStep\",   \"I -> R\" = d_gamma(rate = 1/3, shape = 2) ) parameters <- c(beta = 0.2, rate = 1/3, shape=2, N=1000)  initialValues <- c(S = 999, I = 1, I1 = 1, I2=0, R=0)  # --- Transition def for deSolve transition_func <- function(t, state, param){   with(as.list( c(state, param) ), {        dS = - beta * S * I/N       # apply linear chain trick       dI1 = beta * S * I/N - rate*I1       dI2 = rate*I1 - rate*I2       dI =  dI1 + dI2       dR = rate*I2       list(c(dS, dI, dI1, dI2, dR))   }) }"},{"path":"/articles/denim_vs_deSolve.html","id":"run-simulation-with-denim","dir":"Articles","previous_headings":"Comparison between deSolve and denim","what":"Run simulation with denim","title":"denim vs deSolve","text":"","code":"denim_runtime <- bench::mark(   sim(transitions = transitions, initialValues = initialValues, parameters, simulationDuration = simulationDuration, timeStep = timestep),   iterations = 1 ) denim_runtime <- as.numeric(denim_runtime$total_time)  mod <- sim(transitions = transitions, initialValues = initialValues, parameters, simulationDuration = simulationDuration, timeStep = timestep) # --- show output head(mod[mod$Time %in% 1:simulationDuration,]) ##     Time        S        I          R ## 101    1 998.7825 1.169597 0.04786644 ## 201    2 998.5358 1.296591 0.16756473 ## 301    3 998.2665 1.399083 0.33440701 ## 401    4 997.9783 1.487980 0.53374794 ## 501    5 997.6732 1.569868 0.75697598 ## 601    6 997.3521 1.648745 0.99910771"},{"path":"/articles/denim_vs_deSolve.html","id":"run-simulation-with-desolve","dir":"Articles","previous_headings":"Comparison between deSolve and denim","what":"Run simulation with deSolve","title":"denim vs deSolve","text":"","code":"times <- seq(0, simulationDuration, timestep)  desolve_runtime <- bench::mark(   ode(y = initialValues, times = times, parms = parameters, func = transition_func),   iterations = 1 ) ## Warning: Some expressions had a GC in every iteration; so filtering is ## disabled. desolve_runtime <- as.numeric(desolve_runtime$total_time)  ode_mod <- ode(y = initialValues, times = times, parms = parameters, func = transition_func)  # --- show output ode_mod <- as.data.frame(ode_mod) head(ode_mod[ode_mod$time %in% 1:simulationDuration, c(\"time\", \"S\", \"I\", \"R\")]) ##     time        S        I         R ## 101    1 998.7824 1.169731 0.0479167 ## 201    2 998.5355 1.296752 0.1677463 ## 301    3 998.2660 1.399189 0.3347737 ## 401    4 997.9777 1.487967 0.5343309 ## 501    5 997.6725 1.569688 0.7577887 ## 601    6 997.3515 1.648357 1.0001499"},{"path":"/articles/denim_vs_deSolve.html","id":"execution-time-comparison","dir":"Articles","previous_headings":"Comparison between deSolve and denim","what":"Execution time comparison","title":"denim vs deSolve","text":"denim takes approximately 71.29 times long deSolve compute result given specifications . significant difference can attributed difference approaches: deSolve solves system ODEs denim iterates timestep updates population compartment approach denim allow flexibility types dwell time distributions, computation time scales exponentially timestep grows smaller.","code":""},{"path":"/articles/denim_vs_deSolve.html","id":"plot-the-result","dir":"Articles","previous_headings":"","what":"Plot the result","title":"denim vs deSolve","text":"","code":"# increase timestep before plotting mod <- mod[mod$Time %in% seq(0, simulationDuration, 0.2),] ode_mod <- ode_mod[ode_mod$time %in% seq(0, simulationDuration, 0.2),]"},{"path":[]},{"path":"/articles/denim_vs_deSolve.html","id":"implementation-using-desolve","dir":"Articles","previous_headings":"Comparison with SEIR model","what":"Implementation using deSolve","title":"denim vs deSolve","text":"","code":"library(deSolve) parameters <- c(gamma_rate_I = 1/4, shape_I=2,                 gamma_rate_R = 1/3, shape_R = 2,                 timeStepDur = 1, R0 = 3.5, N = 1e6)  initialValues <- c(S = 999999, E1 = 1,                    E2 = 0, E = 0, I1=0,                     I2=0, I=0, R=0                    )  # --- Transition def for deSolve transition_func <- function(t, state, param){   with(as.list( c(state, param) ), {              tr = (1/gamma_rate_R)*shape_R              dS = - (R0/tr) * S * I/N       # apply linear chain trick       dE1 = (R0/tr) * S * I/N - gamma_rate_I*E1       dE2 = gamma_rate_I*E1 - gamma_rate_I*E2       dE = dE1 + dE2       dI1 = gamma_rate_I*E2 - gamma_rate_R*I1       dI2 = gamma_rate_R*I1 - gamma_rate_R*I2       dI =  dI1 + dI2        dR = gamma_rate_R*I2       list(c(dS, dE1, dE2, dE, dI1, dI2, dI, dR))   }) }  times <- seq(0, 210, 1)  ode_mod <- ode(y = initialValues, times = times, parms = parameters, func = transition_func)  # --- show output ode_mod <- as.data.frame(ode_mod)"},{"path":"/articles/denim_vs_deSolve.html","id":"implementation-using-denim","dir":"Articles","previous_headings":"Comparison with SEIR model","what":"Implementation using denim","title":"denim vs deSolve","text":"","code":"denim_model <- list(   \"S -> E\" = \"(R0/tr) * timeStepDur * S * (I/N)\", # formulate according that of uSEIR method   \"E -> I\" = d_gamma(rate = 1/4, shape = 2),   \"I -> R\" = d_gamma(rate = 1/3, shape = 2) )  initialValues <- c(S = 999999, E = 1, I= 0, R= 0) parameters <- c(R0 = 3.5,                  tr = 3*2, # compute mean recovery time, for gamma it's scale*shape                 N = 1e6, timeStepDur = 0.01)  mod <- sim(transitions = denim_model,                       initialValues = initialValues,                      parameters = parameters,                      simulationDuration = 210, timeStep = 0.01)  # denim_out[, c(\"S\",\"E\", \"I\", \"R\")] <- denim_out[, c(\"S\",\"E\", \"I\", \"R\")]/1e6 plot(mod)"},{"path":[]},{"path":"/articles/denim_vs_uSEIR.html","id":"useir-defined-in-python","dir":"Articles","previous_headings":"","what":"uSEIR defined in Python","title":"denim vs uSEIR","text":"Source code: https://github.com/jjgomezcadenas/useirn/blob/master/nb/uSEIR.ipynb","code":"library(reticulate) ## Warning: package 'reticulate' was built under R version 4.3.1 # use_python(\"/opt/anaconda3/envs/bnn/bin/python\", required = TRUE) use_condaenv(condaenv='bnn', required = TRUE) matplotlib <- import(\"matplotlib\") matplotlib$use(\"Agg\", force = TRUE) from scipy.stats import gamma import matplotlib import matplotlib.pyplot as plt matplotlib.use('Agg') from matplotlib.pyplot import imshow plt.rcParams[\"figure.figsize\"] = 10, 8 plt.rcParams[\"font.size\"     ] = 14 plt.rcParams['savefig.format'] = 'png' import numpy as np import pandas as pd import pyarrow as pa  def plot_useir(dfs, lbls, T = 'uSEIR', figsize=(10,10)):          fig = plt.figure(figsize=figsize)          ax=plt.subplot(1,2,1)     for i, df in enumerate(dfs):         df.head()         ls = f'S-{lbls[i]}'         lr = f'R-{lbls[i]}'         plt.plot(df.t, df.S, lw=2, label=ls)         plt.plot(df.t, df.R, lw=2, label=lr)      plt.xlabel('time (days)')     plt.ylabel('Fraction of population')     plt.legend()     plt.title(T)          ax=plt.subplot(1,2,2)     for i, df in enumerate(dfs):         le = f'E-{lbls[i]}'         li = f'I-{lbls[i]}'         plt.plot(df.t, df.E, lw=2, label=le)         plt.plot(df.t, df.I, lw=2, label=li)      plt.xlabel('time (days)')     plt.ylabel('Fraction of population')     plt.legend()          plt.title(T)     plt.tight_layout()     plt.show()  def solve_uSeir(ti_shape     = 5.5,                      ti_scale     = 1,                     tr_shape     = 6.5,                      tr_scale     = 1,                    R0           = 3.5):     \"\"\"     The pure python version only uses the gamma distribution and fine grain.     It's sole purpose is benchmarking the cython version     \"\"\"          # This function is similar to calcTransitionProb in denim     def compute_gamma_pde(t_shape, t_scale, eps, tol):         # compute dwell time steps unit         ne = int(gamma.ppf(tol, a=t_shape, scale=t_scale) / eps)         # transition rate per timestep          pdE = np.zeros(ne)         cd1 = 0         for i in np.arange(ne):             # equivalent to computing sum(pi_i) in denim             cd2    = gamma.cdf(i*eps, a=t_shape, scale=t_scale)             pdE[i] = cd2-cd1 # equivalent compute current transition prob in denim             cd1    = cd2                  # return values         # ne: equivalent of dwell time in time steps         # pdE: equivalent to p_i in denim paper         return ne, pdE      N       = 1e+6     Smin    = 1e-10      Emin    = 1e-10     nmax    = 21000 # max time steps     eps     = 0.01     tr = tr_shape*tr_scale     prob    = R0 / tr      pn      = prob * eps     tol     = 0.9999 # similar to the error tolerance in denim      nE, pdE = compute_gamma_pde(ti_shape, ti_scale, eps, tol)     nI, pdI = compute_gamma_pde(tr_shape, tr_scale, eps, tol)      print(f' Function solve_uSeir: time epsilon = {eps}')     print(f' statistical distribution is Gamma , ti = {ti_shape*ti_scale}, tr = {tr_shape*tr_scale}')     print(f' number of exposed compartments = {nE}, infected compartments = {nI}')     print(f' R0 = {R0}, prob = {prob}, pn = {pn}')           I   = np.zeros(nI)     E   = np.zeros(nE)     S    = 1 - 1/N     E[0] = 1 / N          R    = 0     sI   = 0      TT = []     SS = []     EE = []     II = []     RR = []     n    = 0          while True:                  # update R compartment           # I[0] here is equivalent to population that will move to R at t + 0 (i.e. current time step)          R += I[0]          # ----- Simulate for S-I first -----         end = nI - 1 # compute dwell time         # update population for I_k where I_k is the population that will move to R at time t + k (in time step)         for k in np.arange(end):             I[k] = I[k+1] + pdI[k] * E[0]              # pdI[k] * E[0] is just contact rate             # where I[k+1] is value computed from previous timestep (i.e. shift I[k+1] from old iteration to I[k] in current iteration)         I[end] = pdI[end] * E[0]                  #print(I)          # ----- Simulate I-E transition -----         end = nE - 1         for k in np.arange(end):             E[k] = E[k+1] + pn * pdE[k] * sI * S         E[end]   = pn * pdE[end] * sI * S          #print(E)                  # pn * sI * S equivalent to probs * epsilon * S * I/N         S  = S - pn * sI * S                  sI = np.sum(I)         sE = np.sum(E)                  #print(sI)         #print(sE)         TT.append(n * eps)         SS.append(S)         EE.append(sE)         II.append(sI)         RR.append(R)                  #print(f't = {n*eps} S = {S} E ={sE} I ={sI} R = {R}')         n+=1         if (sE < Smin and sI < Emin) or n > nmax:             break          df = pd.DataFrame(list(zip(TT, SS, EE, II, RR)),                 columns =['t', 'S', 'E', 'I', 'R'])           return df  # print(plt.gcf().canvas.get_supported_filetypes())"},{"path":"/articles/denim_vs_uSEIR.html","id":"run-simulation-using-pure-python-implementation","dir":"Articles","previous_headings":"uSEIR defined in Python","what":"Run simulation using pure Python implementation","title":"denim vs uSEIR","text":"Run time pure Python implementation ~ 59.9872","code":"import time from statistics import mean  runs = []  # --- Get runtime for 10 runs ---- # for i in range(10): #   start = time.time() #   df = solve_uSeir(ti_shape     = 2, #                      ti_scale     = 4, #                      tr_shape     = 2, #                      tr_scale     = 3, #                      R0           = 3.5) #   end = time.time() #   runs = runs + [end - start] #   mean(runs)    # plot_useir((df,), ('G',), T = 'uSEIR', figsize=(14,8)) # print(f'python solve_seir call: dr = {end-start}')"},{"path":"/articles/denim_vs_uSEIR.html","id":"run-simulation-using-cython-implementation","dir":"Articles","previous_headings":"uSEIR defined in Python","what":"Run simulation using cython implementation","title":"denim vs uSEIR","text":"Run time Cython implementation ~ 0.4140","code":"# import precompiled cython module import sys sys.path.insert(0, \"../supplements\") import useir import time  runs = [] # --- Get runtime for 10 runs ---- # for i in range(10): #   start = time.time() #   df = useir.csolve_uSeir(dist = \"gamma\", #                     ti_shape     = 2,   #                      ti_scale     = 4,  #                      tr_shape     = 2,   #                      tr_scale     = 3, #                      R0           = 3.5 #   ) #   end = time.time() #  #   runs = runs + [end - start] # mean(runs)  df = useir.csolve_uSeir(dist = \"gamma\",                     ti_shape     = 2,                        ti_scale     = 4,                       tr_shape     = 2,                        tr_scale     = 3,                      R0           = 3.5   ) ##  Function compute_pde with sampling = Fine, time epsilon = 0.01 ##  statistical distribution = gamma, ti = 8.0, tr = 6.0 ##  number of exposed compartments = 4702, infected compartments = 3526 ## len pdE = 4702, max(pdE) =0.0009196976461058881 len pdi = 3526 max(pdI) =0.0012262625368251734 ## prob = 0.5833333333333334, pn = 0.005833333333333334 # convert to pyarrow table for easy conversion to R data.frames to_r_df = pa.Table.from_pandas(df)"},{"path":"/articles/denim_vs_uSEIR.html","id":"run-simulation-using-denim","dir":"Articles","previous_headings":"uSEIR defined in Python","what":"Run simulation using denim","title":"denim vs uSEIR","text":"Run time denim implementation ~ 1.002","code":"library(denim)  denim_model <- list(   \"S -> E\" = \"(R0/tr) * timeStepDur * S * (I/N)\", # formulate according that of uSEIR method   \"E -> I\" = d_gamma(scale = 4, shape = 2),   \"I -> R\" = d_gamma(scale = 3, shape = 2) )   initialValues <- c(S = 999999, E = 1, I= 0, R= 0) parameters <- c(R0 = 3.5,                  tr = 3*2, # compute mean recovery time, for gamma it's scale*shape                 N = 1e6, timeStepDur = 0.01)  # ---- Get runtimes of 10 runs ---- # runtimes <- sapply(1:10, #   function (i) { #     time <- system.time( #       sim(transitions = denim_model,  #                      initialValues = initialValues, #                      parameters = parameters, #                      simulationDuration = 210, timeStep = 0.01) #     ) #     return(time[[\"elapsed\"]]) #   }) #  # mean(runtimes)  # ---- Get output ---- denim_out <- sim(transitions = denim_model,                       initialValues = initialValues,                      parameters = parameters,                      simulationDuration = 210, timeStep = 0.01) ## Warning: package 'arrow' was built under R version 4.3.3 ##  ## Attaching package: 'arrow' ## The following object is masked from 'package:utils': ##  ##     timestamp"},{"path":"/articles/multinomial.html","id":"modeling-multinomial-transition-in-denim","dir":"Articles","previous_headings":"","what":"1. Modeling multinomial transition in denim","title":"multinomial transition in denim","text":"Modelers may encounter many situations individuals can transition one compartment multiple others, SIRD model. 2 main approaches handle : Model transitions competing risks Model multinomial transition (outgoing population split fixed proportion transition new compartments) modeling simplicity, denim’s implementation follows multinomial approach. Example: SIRD model 90% infected can recover remaining 10% die. \\[ \\begin{cases} dS = -\\beta S \\frac{}{N} \\\\ dIR_1 = 0.9 *\\beta S \\frac{}{N} -\\frac{1}{3}IR_1 \\\\ dIR_2 = \\frac{1}{3}IR_1 - \\frac{1}{3}IR_2 \\\\ = 0.1*\\beta S \\frac{}{N} - 0.1*ID \\\\ dR = \\frac{1}{3}IR_2 \\\\ dD = 0.1*ID \\end{cases} \\]","code":"transitions <- list(   \"S -> I\" = \"beta * S * (I / N) * timeStep\",   \"0.9 * I -> R\" = d_gamma(1/3, 2),   \"0.1 * I -> D\" = d_exponential(0.1) )"},{"path":"/articles/multinomial.html","id":"proportion-normalization","dir":"Articles","previous_headings":"1. Modeling multinomial transition in denim","what":"Proportion normalization","title":"multinomial transition in denim","text":"denim automatically normalize proportions don’t sum 1. Example 2: following model definition equivalent one Example 1","code":"transitions <- list(   \"S -> I\" = \"beta * S * (I / N) * timeStep\",   \"36 * I -> R\" = d_gamma(1/3, 2),   \"4 * I -> D\" = d_exponential(0.1) )"},{"path":"/articles/multinomial.html","id":"implicit-multinomial","dir":"Articles","previous_headings":"1. Modeling multinomial transition in denim","what":"Implicit multinomial","title":"multinomial transition in denim","text":"proportion given, denim automatically distribute outgoing population transition uniformly Example 3: following 2 models equivalent","code":"transitions <- list(   \"S -> I\" = \"beta * S * (I / N) * timeStep\",   \"I -> R\" = d_gamma(1/3, 2),   \"I -> D\" = d_exponential(0.1) )  transitions <- list(   \"S -> I\" = \"beta * S * (I / N) * timeStep\",   \"0.5 * I -> R\" = d_gamma(1/3, 2),   \"0.5 * I -> D\" = d_exponential(0.1) )"},{"path":"/articles/multinomial.html","id":"example-model","dir":"Articles","previous_headings":"","what":"2. Example model","title":"multinomial transition in denim","text":"demonstrate implementation multinomial denim, provide equivalent model implemented deSolve compare output 2 implementations.","code":""},{"path":"/articles/multinomial.html","id":"model-definition-in-denim","dir":"Articles","previous_headings":"2. Example model","what":"Model definition in denim","title":"multinomial transition in denim","text":"","code":"# model in denim transitions <- list(   \"S -> I\" = \"beta * S * (I / N) * timeStep\",   \"0.9 * I -> R\" = d_gamma(1/3, 2),   \"0.1 * I -> D\" = d_exponential(0.1) )  denimInitialValues <- c(   S = 999,    I = 1,    R = 0,   D = 0 )"},{"path":"/articles/multinomial.html","id":"equivalent-model-definition-in-desolve","dir":"Articles","previous_headings":"2. Example model","what":"Equivalent model definition in deSolve","title":"multinomial transition in denim","text":"","code":"# model in deSolve transition_func <- function(t, state, param){   with(as.list( c(state, param) ), {        dS = - beta * S * (IR1 + IR2 + ID)/N       # apply linear chain trick for I -> R transition       # 0.9 * to specify prop of I that goes to I->R transition       dIR1 = 0.9 * beta * S * (IR1 + IR2 + ID)/N - rate*IR1       dIR2 = rate*IR1 - rate*IR2       dR = rate*IR2               # handle I -> D transition       # 0.1 * to specify prop of I that goes to I->D transition       dID = 0.1 * beta * S * (IR1 + IR2 + ID)/N - exp_rate*ID       dD = exp_rate*ID       list(c(dS, dIR1, dIR2, dID, dR, dD))   }) }  desolveInitialValues <- c(   S = 999,    # note that internally, denim also allocate initial value based on specified proportion   IR1 = 0.9,   IR2 = 0,   ID = 0.1,    R = 0,   D = 0 )"},{"path":"/articles/multinomial.html","id":"run-simulation-and-compare","dir":"Articles","previous_headings":"2. Example model","what":"Run simulation and compare","title":"multinomial transition in denim","text":"Output Comparison","code":"parameters <- c(   beta = 0.2,   N = 1000,   rate = 1/3,   exp_rate = 0.1 )  simulationDuration <- 200 timeStep <- 0.05 # --- run denim model ----  mod <- sim(transitions = transitions,             initialValues = denimInitialValues,             parameters = parameters,             simulationDuration = simulationDuration,             timeStep = timeStep)  # run deSolve model times <- seq(0, simulationDuration) ode_mod <- ode(y = desolveInitialValues, times = times, parms = parameters, func = transition_func)  ode_mod <- as.data.frame(ode_mod) ode_mod$I<- rowSums(ode_mod[, c(\"IR1\", \"IR2\", \"ID\")]) # ---- Plot S compartment plot(x = mod$Time, y = mod$S,xlab = \"Time\", ylab = \"Count\", main=\"S compartment\",      col = \"#4876ff\", type=\"l\", lwd=3) lines(ode_mod$time, ode_mod$S, lwd=3, lty=3) legend(x = 150, y = 850,legend=c(\"denim\", \"deSolve\"), col = c(\"#4876ff\", \"black\"), lty=c(1,3)) # ---- Plot I compartment plot(x = mod$Time, y = mod$I, xlab = \"Time\", ylab = \"Count\", main=\"I compartment\",       col = \"#4876ff\", type=\"l\", lwd=2) lines(ode_mod$time, ode_mod$I, lwd=3, lty=3) legend(x = 150, y = 25,legend=c(\"denim\", \"deSolve\"), col = c(\"#4876ff\", \"black\"), lty=c(1,3)) # ---- Plot R compartment plot(x = mod$Time, y = mod$R, xlab = \"Time\", ylab = \"Count\", main=\"R compartment\",       col = \"#4876ff\", type=\"l\", lwd=2) lines(ode_mod$time, ode_mod$R, lwd=3, lty=3) legend(x = 150, y = 250,legend=c(\"denim\", \"deSolve\"), col = c(\"#4876ff\", \"black\"), lty=c(1,3)) # ---- Plot D compartment plot(x = mod$Time, y = mod$D, xlab = \"Time\", ylab = \"Count\", main=\"D compartment\",      col = \"#4876ff\", type=\"l\", lwd=2) lines(ode_mod$time, ode_mod$D, lwd=3, lty=3) legend(x = 150, y = 25,legend=c(\"denim\", \"deSolve\"), col = c(\"#4876ff\", \"black\"), lty=c(1,3))"},{"path":"/articles/web_only/denim.html","id":"simple-sir-model-with-gamma-distributed-lengths-of-stay","dir":"Articles > Web_only","previous_headings":"","what":"1. Simple SIR model with gamma distributed lengths of stay","title":"denim: deterministic discrete-time model with memory","text":"SIR model uses 3 compartments: S (susceptible), (infected), R (recovered) describe clinical status individuals. use simple form SIR model demonstrate define distribution lengths stay distribution. model equations : \\[S_{t+1} - S_{t} = -\\lambda S_{t} = -\\frac{\\beta I_{t}}{N}S_{t}\\] \\[I_{t+1} - I_{t} = \\frac{\\beta I_{t}}{N}S_{t} - \\gamma I_{t}\\] \\[R_{t+1} - R_{t} = \\gamma I_{t}\\] \\(N\\): total population size, \\(N = S + + R\\) \\(\\beta\\): product contact rates transmission probability; usually define \\(\\lambda =\\frac{\\beta I_{t}}{N}\\) force infection \\(\\gamma\\): recovery rate Usually solve model easier make assumption recovery rate \\(\\gamma\\) constant, leads exponentially distributed length stay .e individuals recover 1 day infected.  realistic length stay distribution can look like , patients recovered 4 days. defined using gamma distribution shape = 3 scale = 2.  model now look like : Model specification Model transition two transitions S -> -> R case. transitions specified list follow format \"transition\" = equation, equation defined one functions waiting time distribution. Initial state Use vector define compartments assigned names initial values format compartment_name = initial_value: Model parameters use math expression, symbols except compartment names parameters, defined constant values. two constant parameters example: beta N: Model application Time step specification run model 30 days give output 0.01 daily intervals. default interval (time step) 1 declared explicitly.","code":"transitions <- list(   \"S -> I\" = \"beta * S * I / N\",   \"I -> R\" = d_gamma(3, 2) ) initialValues <- c(   S = 999,    I = 1,    R = 0 ) parameters <- c(   beta = 0.012,   N = 1000 ) simulationDuration <- 30 timeStep <- 0.01 mod <- sim(transitions = transitions,             initialValues = initialValues,             parameters = parameters,             simulationDuration = simulationDuration,             timeStep = timeStep) head(mod) #>   Time        S        I            R #> 1 0.00 999.0000 1.000000 0.000000e+00 #> 2 0.01 998.9880 1.011982 5.543225e-06 #> 3 0.02 998.9759 1.024097 2.219016e-05 #> 4 0.03 998.9636 1.036346 5.000038e-05 #> 5 0.04 998.9512 1.048730 8.903457e-05 #> 6 0.05 998.9386 1.061252 1.393545e-04 plot(mod)"},{"path":"/articles/web_only/denim.html","id":"how-the-algorithm-work","dir":"Articles > Web_only","previous_headings":"","what":"2. How the algorithm work?","title":"denim: deterministic discrete-time model with memory","text":"SIR model, infected individuals presented single compartment recovery rate \\(\\gamma\\). want recovery rate individuals infected 1 day differ recovery rate 2-day infected patients. rather using one compartment infected (), define multiple infected sub-compartments. number sub-compartments depends maximum day expect infected individuals recovered. example, expect disease maximum 4 days infection, end 4 sub-compartments. sub-compartment recovery rate \\(\\gamma_{1}\\), \\(\\gamma_{2}\\), \\(\\gamma_{3}\\), \\(\\gamma_{4}\\). day 4 certain patient recover (assume disease maximum 4 days infection), \\(\\gamma_{4} = 1\\). Let \\(R_1 + R_2 + R_3 + R_4 = \\Sigma R\\). \\(\\frac{R_1}{\\Sigma R} = p_1\\), \\(\\frac{R_2}{\\Sigma R} = p_2\\), \\(\\frac{R_3}{\\Sigma R} = p_3\\), \\(\\frac{R_4}{\\Sigma R} = p_4\\). mission estimate \\(\\gamma_{1}\\), \\(\\gamma_{2}\\), \\(\\gamma_{3}\\) obtain \\(p_1\\), \\(p_2\\), \\(p_3\\), \\(p_4\\) fit pre-defined distribution equilibrium state. can obtained setting: \\[\\gamma_{} = \\frac{p_i}{1 - \\sum_{j=1}^{-1}p_j}\\] given length stay distribution, identify maximum length stay using cumulative distribution function. cumulative distribution function asymptotic 1 never equal 1, need set value acceptable rounded 1. want cumulative probability 0.999 rounded 1, set error tolerance threshold 1 - 0.999 = 0.001 (specified argument errorTolerance = 0.001). time cumulative probability = 0.999 set maximum length stay compartment. Default errorTolerance denim set 0.001.","code":""},{"path":"/articles/web_only/denim.html","id":"waiting-time-distribution","dir":"Articles > Web_only","previous_headings":"","what":"3. Waiting time distribution","title":"denim: deterministic discrete-time model with memory","text":"Current available distribution package including: d_exponential(rate): Discrete exponential distribution parameter rate d_gamma(scale, shape): Discrete gamma distribution parameters scale shape d_weibull(scale, shape): Discrete Weibull distribution parameters scale shape d_lognormal(mu, sigma): Discrete log-normal distribution parameters mu sigma can define type transitions : Mathematical expression: Transition defined string value \"beta * S * / N\" converted mathematical expression. need define parameters compartment names parameters argument Constant: Transition defined numerical value 1, 2 converted constant. define number individuals moving time step. transprob(x): Every time step fixed percentage left compartment transit right compartment, also convenient way define \\(R_t - R_{t-1} = \\gamma \\) can input \"-> R\" = transprob(gamma) nonparametric(waitingTimes...): vector values, numbers, percentages, density length stay based real data, denim convert distribution multinomial(probabilities): convenient way define several probabilities compartment transit many compartments, may may time step. example, \"V -> VA, VS, VH\" = multinomial(0.6, 0.3, 0.1) means 60% V become VA, 30% become VS 10% become VH. continue define length stay distribution transitions e.g \"V -> VA\" = d_gamma(3, 2), probabilities defined multinomial() percentage left compartment transit time step, percentage individuals move VA equilibrium state. define length stay distribution, \"V -> VA, VS, VH\" = multinomial(0.6, 0.3, 0.1) percentage V transit right compartments per time step similar transprob() function. See detailed explanations Multiple transitions compartment section.","code":""},{"path":"/articles/web_only/denim.html","id":"multiple-transitions-from-a-compartment","dir":"Articles > Web_only","previous_headings":"","what":"4. Multiple transitions from a compartment","title":"denim: deterministic discrete-time model with memory","text":"many ways define type transition two transitions compartment. Consider example: two scenarios example: Susceptible individuals can infected vaccinated. assumption infected first (S -> ), rest infected get vaccinated (S -> V). Infected individuals can recover die. mortality probability known, can implement model, example defining 0.9 * -> R (90% individuals recover) 0.1 * -> D (10% die). , ensure mortality probability 10%, also define length stay individuals infected state recover die follows gamma log-normal distribution, respectively. can define model example follows:  Tips: Instead writing: can also use multinomial(), define length stay distribution obtain result:","code":"transitions <- list(   \"S -> I\" = \"beta * S * I / N\",   \"S -> V\" = 7,   \"0.9 * I -> R\" = d_gamma(3, 2),   \"0.1 * I -> D\" = d_lognormal(2, 0.5) )  initialValues <- c(   S = 999,    I = 1,    R = 0,   V = 0,   D = 0 )  parameters <- c(   beta = 0.12,   N = 1000 )  simulationDuration <- 10 timeStep <- 0.01  mod <- sim(transitions = transitions,             initialValues = initialValues,             parameters = parameters,             simulationDuration = simulationDuration,             timeStep = timeStep) plot(mod) \"0.9 * I -> R\" = d_gamma(3, 2), \"0.1 * I -> D\" = d_lognormal(2, 0.5) \"I -> R, D\" = multinomial(0.9, 0.1), \"I -> R\" = d_gamma(3, 2), \"I -> D\" = d_lognormal(2, 0.5)"},{"path":"/articles/web_only/denim.html","id":"another-example","dir":"Articles > Web_only","previous_headings":"","what":"5. Another example","title":"denim: deterministic discrete-time model with memory","text":"","code":"transitions <- list(   \"S -> I\" = \"beta * S * (I + IV) / N\",   \"S -> V\" = 2,   \"0.1 * I -> D\" = d_lognormal(2, 0.5),   \"0.9 * I -> R\" = d_gamma(3, 2),   \"V -> IV\" = \"0.1 * beta * V * (I + IV) / N\",   \"IV -> R\" = d_exponential(2) )  initialValues <- c(   S = 999,    I = 1,    R = 0,   V = 0,   IV = 0,   D = 0 )  parameters <- c(   beta = 0.12,   N = 1000 )  simulationDuration <- 10 timeStep <- 0.01  mod <- sim(transitions = transitions,             initialValues = initialValues,             parameters = parameters,             simulationDuration = simulationDuration,             timeStep = timeStep) plot(mod)"},{"path":"/articles/web_only/denim_vs_deSolve.html","id":"comparison-between-desolve-and-denim","dir":"Articles > Web_only","previous_headings":"","what":"Comparison between deSolve and denim","title":"denim vs deSolve","text":"Using deSolve, can replicate Erlang distribution exponential distribution testing","code":"library(denim) library(deSolve) ## Warning: package 'deSolve' was built under R version 4.3.1 # --- Transition def for denim transitions <- list(   \"S -> I\" = d_exponential(0.2),   \"I -> R\" = d_gamma(3, 2) ) parameters <- c(rate = 0.2, scale = 3, shape=2)  initialValues <- c(S = 999, I = 1, I1 = 1, I2=0, R=0)  # --- Transition def for deSolve transition_func <- function(t, state, param){   with(as.list( c(state, param) ), {       gamma_rate = 1/scale       dS = -rate*S       # apply linear chain trick       dI1 = rate*S - gamma_rate*I1       dI2 = gamma_rate*I1 - gamma_rate*I2       dI =  dI1 + dI2       dR = gamma_rate*I2       list(c(dS, dI, dI1, dI2, dR))   }) }  # --- Timestep definition simulationDuration <- 20  timestep <- 0.001 # small timestep required for comparison"},{"path":"/articles/web_only/denim_vs_deSolve.html","id":"run-simulation-with-denim","dir":"Articles > Web_only","previous_headings":"Comparison between deSolve and denim","what":"Run simulation with denim","title":"denim vs deSolve","text":"","code":"denim_start <- Sys.time() mod <- sim(transitions = transitions, initialValues = initialValues, parameters, simulationDuration = simulationDuration, timeStep = timestep) denim_end <- Sys.time()  # --- show output head(mod[mod$Time %in% 1:simulationDuration,]) ##      Time        S        I          R ## 1001    1 817.9120 179.0627   3.025308 ## 2001    2 669.6497 310.8811  19.469173 ## 3001    3 548.2628 398.4336  53.303539 ## 4001    4 448.8796 448.0932 103.027204 ## 5001    5 367.5116 467.6504 164.838060 ## 6001    6 300.8930 464.7307 234.376244"},{"path":"/articles/web_only/denim_vs_deSolve.html","id":"run-simulation-with-desolve","dir":"Articles > Web_only","previous_headings":"Comparison between deSolve and denim","what":"Run simulation with deSolve","title":"denim vs deSolve","text":"","code":"times <- seq(0, simulationDuration, timestep)  desolve_start <- Sys.time() ode_mod <- ode(y = initialValues, times = times, parms = parameters, func = transition_func) desolve_end <- Sys.time()  # --- show output ode_mod <- as.data.frame(ode_mod) head(ode_mod[ode_mod$time %in% 1:simulationDuration, c(\"time\", \"S\", \"I\", \"R\")]) ##      time        S        I          R ## 1001    1 817.9120 179.0585   3.029466 ## 2001    2 669.6497 310.8686  19.481654 ## 3001    3 548.2628 398.4125  53.324630 ## 4001    4 448.8796 448.0650 103.055392 ## 5001    5 367.5116 467.6172 164.871207 ## 6001    6 300.8930 464.6948 234.412204"},{"path":"/articles/web_only/denim_vs_deSolve.html","id":"execution-time-comparison","dir":"Articles > Web_only","previous_headings":"Comparison between deSolve and denim","what":"Execution time comparison","title":"denim vs deSolve","text":"denim takes approximately 101.74 times long deSolve compute result given specifications . significant difference can attributed difference approaches: deSolve solves system ODEs denim iterates timestep updates population compartment approach denim allow flexibility types dwell time distributions, computation time scales timestep grows smaller (O(n) time complexity).","code":""},{"path":"/articles/web_only/denim_vs_deSolve.html","id":"plot-the-result","dir":"Articles > Web_only","previous_headings":"","what":"Plot the result","title":"denim vs deSolve","text":"","code":"# increase timestep before plotting mod <- mod[mod$Time %in% seq(0, simulationDuration, 0.2),] ode_mod <- ode_mod[ode_mod$time %in% seq(0, simulationDuration, 0.2),] # ---- Plot S compartment plot(x = mod$Time, y = mod$S,xlab = \"Time\", ylab = \"Count\", main=\"S compartment\",      col = \"#4876ff\", type=\"l\", lwd=3) lines(ode_mod$time, ode_mod$S, lwd=3, lty=3) legend(x = 15, y = 900,legend=c(\"denim\", \"deSolve\"), col = c(\"#4876ff\", \"black\"), lty=c(1,3)) # ---- Plot I compartment plot(x = mod$Time, y = mod$I, xlab = \"Time\", ylab = \"Count\", main=\"I compartment\",       col = \"#4876ff\", type=\"l\", lwd=2) lines(ode_mod$time, ode_mod$I, lwd=3, lty=3) legend(x = 15, y = 350,legend=c(\"denim\", \"deSolve\"), col = c(\"#4876ff\", \"black\"), lty=c(1,3)) # ---- Plot R compartment plot(x = mod$Time, y = mod$R, xlab = \"Time\", ylab = \"Count\", main=\"R compartment\",      col = \"#4876ff\", type=\"l\", lwd=2) lines(ode_mod$time, ode_mod$R, lwd=3, lty=3) legend(x = 15, y = 300,legend=c(\"denim\", \"deSolve\"), col = c(\"#4876ff\", \"black\"), lty=c(1,3))"},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Thinh Ong. Author, copyright holder. Anh Phan. Author, maintainer. Marc Choisy. Author. Niels Lohman. Contributor. Bjoern Hoehrmann. Contributor. Florian Loitsch. Contributor. Ingo Berg. Contributor.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Ong T, Phan , Choisy M (2025). denim: Generate Simulate Deterministic Discrete-Time Compartmental Models. https://drthinhong.com/denim/, https://github.com/thinhong/denim.","code":"@Manual{,   title = {denim: Generate and Simulate Deterministic Discrete-Time Compartmental Models},   author = {Thinh Ong and Anh Phan and Marc Choisy},   year = {2025},   note = {https://drthinhong.com/denim/, https://github.com/thinhong/denim}, }"},{"path":"/index.html","id":"denim-","dir":"","previous_headings":"","what":"Generate and Simulate Deterministic Discrete-Time Compartmental Models","title":"Generate and Simulate Deterministic Discrete-Time Compartmental Models","text":"R package building simulating deterministic discrete-time compartmental models memory.","code":""},{"path":"/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Generate and Simulate Deterministic Discrete-Time Compartmental Models","text":"can install development version denim GitHub :","code":"# install.packages(\"devtools\") devtools::install_github(\"thinhong/denim\")"},{"path":"/index.html","id":"example","dir":"","previous_headings":"","what":"Example","title":"Generate and Simulate Deterministic Discrete-Time Compartmental Models","text":"basic example illustrate specification simple SIR model, contains three compartments susceptible (S), infected () recovered (R). recovery probabilities infected individuals gamma distributed example: output data frame 4 columns: Time, S, R can plot output :","code":"library(denim)  transitions <- list(   \"S -> I\" = \"beta * S * I / N\",   \"I -> R\" = d_gamma(rate = 1/3, shape = 2) )  parameters <- c(   beta = 0.12,   N = 1000 )  initialValues <- c(   S = 999,    I = 1,    R = 0 )  simulationDuration <- 10 timeStep <- 0.01  mod <- sim(transitions = transitions, initialValues = initialValues,             parameters = parameters, simulationDuration = simulationDuration,             timeStep = timeStep) head(mod) #>   Time        S        I            R #> 1 0.00 999.0000 1.000000 0.000000e+00 #> 2 0.01 998.8801 1.119874 5.543225e-06 #> 3 0.02 998.7459 1.254092 2.278823e-05 #> 4 0.03 998.5956 1.404364 5.306419e-05 #> 5 0.04 998.4273 1.572606 9.785981e-05 #> 6 0.05 998.2389 1.760961 1.588423e-04 plot(mod)"},{"path":"/reference/constant.html","id":null,"dir":"Reference","previous_headings":"","what":"Fixed transition — constant","title":"Fixed transition — constant","text":"Define fixed number individuals left compartment transit right compartment every time step","code":""},{"path":"/reference/constant.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fixed transition — constant","text":"","code":"constant(x)"},{"path":"/reference/constant.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fixed transition — constant","text":"x number individuals move one compartment another","code":""},{"path":"/reference/constant.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fixed transition — constant","text":"Distribution object simulator","code":""},{"path":"/reference/constant.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fixed transition — constant","text":"","code":"transitions <- list(\"S->I\" = constant(10))"},{"path":"/reference/d_exponential.html","id":null,"dir":"Reference","previous_headings":"","what":"Discrete exponential distribution — d_exponential","title":"Discrete exponential distribution — d_exponential","text":"Discrete exponential distribution","code":""},{"path":"/reference/d_exponential.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Discrete exponential distribution — d_exponential","text":"","code":"d_exponential(rate, dist_init = FALSE)"},{"path":"/reference/d_exponential.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Discrete exponential distribution — d_exponential","text":"rate rate parameter exponential distribution dist_init whether distribute initial value across subcompartments following distribution. (default FALSE, meaning init value always first compartment)","code":""},{"path":"/reference/d_exponential.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Discrete exponential distribution — d_exponential","text":"Distribution object simulator","code":""},{"path":"/reference/d_exponential.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Discrete exponential distribution — d_exponential","text":"","code":"transitions <- list(\"I -> D\" = d_exponential(0.3))"},{"path":"/reference/d_gamma.html","id":null,"dir":"Reference","previous_headings":"","what":"Discrete gamma distribution — d_gamma","title":"Discrete gamma distribution — d_gamma","text":"Discrete gamma distribution","code":""},{"path":"/reference/d_gamma.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Discrete gamma distribution — d_gamma","text":"","code":"d_gamma(rate, shape, dist_init = FALSE)"},{"path":"/reference/d_gamma.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Discrete gamma distribution — d_gamma","text":"rate rate parameter gamma distribution shape shape parameter gamma distribution dist_init whether distribute initial value across subcompartments following distribution.","code":""},{"path":"/reference/d_gamma.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Discrete gamma distribution — d_gamma","text":"Distribution object simulator","code":""},{"path":"/reference/d_gamma.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Discrete gamma distribution — d_gamma","text":"","code":"transitions <- list(\"S -> I\" = d_gamma(rate = 1, shape = 5))"},{"path":"/reference/d_lognormal.html","id":null,"dir":"Reference","previous_headings":"","what":"Discrete log-normal distribution — d_lognormal","title":"Discrete log-normal distribution — d_lognormal","text":"Discrete log-normal distribution","code":""},{"path":"/reference/d_lognormal.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Discrete log-normal distribution — d_lognormal","text":"","code":"d_lognormal(mu, sigma, dist_init = FALSE)"},{"path":"/reference/d_lognormal.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Discrete log-normal distribution — d_lognormal","text":"mu location parameter ln mean sigma scale parameter ln standard deviation dist_init whether distribute initial value across subcompartments following distribution. (default FALSE, meaning init value always first compartment)","code":""},{"path":"/reference/d_lognormal.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Discrete log-normal distribution — d_lognormal","text":"Distribution object simulator","code":""},{"path":"/reference/d_lognormal.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Discrete log-normal distribution — d_lognormal","text":"","code":"transitions <- list(\"I -> D\" = d_lognormal(3, 0.6))"},{"path":"/reference/d_weibull.html","id":null,"dir":"Reference","previous_headings":"","what":"Discrete Weibull distribution — d_weibull","title":"Discrete Weibull distribution — d_weibull","text":"Discrete Weibull distribution","code":""},{"path":"/reference/d_weibull.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Discrete Weibull distribution — d_weibull","text":"","code":"d_weibull(scale, shape, dist_init = FALSE)"},{"path":"/reference/d_weibull.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Discrete Weibull distribution — d_weibull","text":"scale scale parameter Weibull distribution shape shape parameter Weibull distribution dist_init whether distribute initial value across subcompartments following distribution. (default FALSE, meaning init value always first compartment)","code":""},{"path":"/reference/d_weibull.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Discrete Weibull distribution — d_weibull","text":"Distribution object simulator","code":""},{"path":"/reference/d_weibull.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Discrete Weibull distribution — d_weibull","text":"","code":"transitions <- list(\"I -> D\" = d_weibull(0.6, 2))"},{"path":"/reference/denim-package.html","id":null,"dir":"Reference","previous_headings":"","what":"denim — denim-package","title":"denim — denim-package","text":"Simulate deterministic discrete time model","code":""},{"path":"/reference/denim-package.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"denim — denim-package","text":"Imports","code":""},{"path":[]},{"path":"/reference/denim-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"denim — denim-package","text":"Maintainer: Anh Phan anhptq@oucru.org (ORCID) Authors: Thinh Ong thinhop@oucru.org (ORCID) [copyright holder] Marc Choisy mchoisy@oucru.org (ORCID) contributors: Niels Lohman [contributor] Bjoern Hoehrmann bjoern@hoehrmann.de [contributor] Florian Loitsch [contributor] Ingo Berg [contributor]","code":""},{"path":"/reference/mathexpr.html","id":null,"dir":"Reference","previous_headings":"","what":"Mathematical expression — mathexpr","title":"Mathematical expression — mathexpr","text":"Mathematical expression","code":""},{"path":"/reference/mathexpr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Mathematical expression — mathexpr","text":"","code":"mathexpr(expr)"},{"path":"/reference/mathexpr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Mathematical expression — mathexpr","text":"expr User defined mathematial expression. expression processed muparser library offers wide variety operators. Visit muparser website (https://beltoforion.de/en/muparser/features.php) see full list available operators.","code":""},{"path":"/reference/mathexpr.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Mathematical expression — mathexpr","text":"Distribution object simulator","code":""},{"path":"/reference/mathexpr.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Mathematical expression — mathexpr","text":"","code":"transitions <- list(\"S->I\"=mathexpr(\"beta*S/N\")) # definition for parameters in the expression required params <- c(N = 1000, beta = 0.3)"},{"path":"/reference/multinomial.html","id":null,"dir":"Reference","previous_headings":"","what":"Multinomial — multinomial","title":"Multinomial — multinomial","text":"Define set probabilities transition one compartment multiple compartments   equal ","code":"\"I -> R\" = d_gamma(1/3, 2), \"I -> D\" = d_lognormal(2, 0.5) \"0.5 * I -> R\" = d_gamma(1/3, 2), \"0.5 * I -> D\" = d_lognormal(2, 0.5)"},{"path":"/reference/multinomial.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Multinomial — multinomial","text":"","code":"multinomial(...)"},{"path":"/reference/multinomial.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Multinomial — multinomial","text":"... vector probabilities. Vector automatically rescaled sum 1.","code":""},{"path":"/reference/multinomial.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Multinomial — multinomial","text":"Distribution object simulator","code":""},{"path":"/reference/nonparametric.html","id":null,"dir":"Reference","previous_headings":"","what":"Nonparametric distribution — nonparametric","title":"Nonparametric distribution — nonparametric","text":"Convert vector frequencies, percentages... distribution","code":""},{"path":"/reference/nonparametric.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Nonparametric distribution — nonparametric","text":"","code":"nonparametric(...)"},{"path":"/reference/nonparametric.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Nonparametric distribution — nonparametric","text":"... vector values","code":""},{"path":"/reference/nonparametric.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Nonparametric distribution — nonparametric","text":"Distribution object simulator","code":""},{"path":"/reference/nonparametric.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Nonparametric distribution — nonparametric","text":"","code":"transitions <- list(\"S->I\"=nonparametric(0.1, 0.2, 0.5, 0.2))"},{"path":"/reference/sim.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulator for deterministic discrete time model with memory — sim","title":"Simulator for deterministic discrete time model with memory — sim","text":"Simulation function call C++ simulator","code":""},{"path":"/reference/sim.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulator for deterministic discrete time model with memory — sim","text":"","code":"sim(   transitions,   initialValues,   parameters = NULL,   simulationDuration,   timeStep = 1,   errorTolerance = 0.001 )"},{"path":"/reference/sim.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulator for deterministic discrete time model with memory — sim","text":"transitions list transitions follows format \"transition\" = distribution() initialValues vector contains initial values compartments defined transitions, follows format compartment_name = initial_value parameters vector contains values parameters compartments, usually parameters used mathexp() functions simulationDuration duration time simulate timeStep set output time interval. example, simulationDuration = 10 means 10 days timeStep = 0.1, output display results 0.1 daily interval errorTolerance set threshold cumulative distribution function can rounded 1. example, want cumulative probability 0.999 rounded 1, set errorTolerance = 0.001 (1 - 0.999 = 0.001). Default 0.001","code":""},{"path":"/reference/sim.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulator for deterministic discrete time model with memory — sim","text":"data.frame class denim can plotted plot() method","code":""},{"path":"/reference/sim.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulator for deterministic discrete time model with memory — sim","text":"","code":"transitions <- list(    \"S -> I\" = \"beta * S * I / N\",    \"I -> R\" = d_gamma(1/3, 2) )  initialValues <- c(    S = 999,     I = 1,     R = 0 )  parameters <- c(    beta = 0.012,    N = 1000 )  simulationDuration <- 30 timeStep <- 0.01  mod <- sim(transitions = transitions,             initialValues = initialValues,             parameters = parameters,             simulationDuration = simulationDuration,             timeStep = timeStep)"},{"path":"/reference/transprob.html","id":null,"dir":"Reference","previous_headings":"","what":"Transition probability — transprob","title":"Transition probability — transprob","text":"fixed percentage left compartment transit right compartment every time step","code":""},{"path":"/reference/transprob.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Transition probability — transprob","text":"","code":"transprob(x)"},{"path":"/reference/transprob.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Transition probability — transprob","text":"x float number 0 1","code":""},{"path":"/reference/transprob.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Transition probability — transprob","text":"Distribution object simulator","code":""},{"path":"/reference/transprob.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Transition probability — transprob","text":"","code":"transitions <- list(\"S->I\"=transprob(0.8))"},{"path":"/news/index.html","id":"denim-101","dir":"Changelog","previous_headings":"","what":"denim 1.0.1","title":"denim 1.0.1","text":"CRAN release: 2025-03-17 Remove deprecated syntax C++","code":""},{"path":"/news/index.html","id":"denim-100","dir":"Changelog","previous_headings":"","what":"denim 1.0.0","title":"denim 1.0.0","text":"CRAN release: 2024-06-05 Initial CRAN submission.","code":""}]
